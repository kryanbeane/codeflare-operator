# CVE Remediation Controller: scan stream branch for a CVE; if affected, open fix PR via Renovate, then recheck PR and close with comment if still vulnerable.
# Trigger: workflow_dispatch with cve_id and base_branch. Secret: CVE_CONTROLLER_PAT (repo scope).

name: CVE Remediation Controller

on:
  workflow_dispatch:
    inputs:
      cve_id:
        description: 'CVE identifier (e.g., CVE-2024-12345)'
        required: true
        type: string
      base_branch:
        description: 'Base branch to scan and target for fix (e.g., rhoai-2.16)'
        required: true
        type: string
      repo_override:
        description: 'E2E only: repo instead of prod'
        required: false
        type: string
      force_recheck_fail:
        description: 'E2E only: force recheck to fail'
        required: false
        type: string

concurrency:
  group: cve-operator-${{ github.event.inputs.repo_override || 'prod' }}-${{ github.event.inputs.cve_id }}-${{ github.event.inputs.base_branch }}
  cancel-in-progress: false

env:
  TARGET_REPO: ${{ github.event.inputs.repo_override || 'red-hat-data-services/codeflare-operator' }}
  CONFIG_REPO: ${{ github.event.inputs.repo_override || 'project-codeflare/codeflare-operator' }}

jobs:
  scan:
    name: Scan for CVE
    runs-on: ubuntu-latest
    outputs:
      go_vulnerable: ${{ steps.scan.outputs.go_vulnerable }}
      go_package: ${{ steps.scan.outputs.go_package }}
      go_module_unknown: ${{ steps.scan.outputs.go_module_unknown }}
      pip_vulnerable: ${{ steps.scan.outputs.pip_vulnerable }}
      pip_package: ${{ steps.scan.outputs.pip_package }}
      vulnerable: ${{ steps.scan.outputs.vulnerable }}
      fix_branch: ${{ steps.branch.outputs.fix_branch }}

    steps:
      - name: Validate inputs
        run: |
          CVE_ID="${{ github.event.inputs.cve_id }}"
          BASE_BRANCH="${{ github.event.inputs.base_branch }}"
          if [ -z "$CVE_ID" ] || ! echo "$CVE_ID" | grep -qE '^CVE-[0-9]{4}-[0-9]+'; then
            echo "::error title=Invalid cve_id::Expected format CVE-YYYY-NNNNN (e.g. CVE-2024-12345)"
            exit 1
          fi
          if [ -z "$BASE_BRANCH" ]; then
            echo "::error title=Invalid base_branch::base_branch is required"
            exit 1
          fi

      - name: Generate fix branch name
        id: branch
        run: |
          CVE_ID="${{ github.event.inputs.cve_id }}"
          BASE_BRANCH="${{ github.event.inputs.base_branch }}"
          FIX_BRANCH="cve-fix/${CVE_ID}-${BASE_BRANCH}"
          FIX_BRANCH=$(echo "$FIX_BRANCH" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9./-]/-/g')
          echo "fix_branch=${FIX_BRANCH}" >> $GITHUB_OUTPUT

      - name: Create fix branch from base branch
        run: |
          FIX_BRANCH="${{ steps.branch.outputs.fix_branch }}"
          BASE_BRANCH="${{ github.event.inputs.base_branch }}"
          git clone --depth 1 --branch "${BASE_BRANCH}" https://x-access-token:${{ secrets.CVE_CONTROLLER_PAT }}@github.com/${{ env.TARGET_REPO }}.git repo
          cd repo
          git config user.email "cve-controller@github.com"
          git config user.name "CVE Controller"
          if git ls-remote --heads origin "${FIX_BRANCH}" | grep -q .; then
            echo "Branch ${FIX_BRANCH} already exists"
          else
            git checkout -b "${FIX_BRANCH}"
            git push origin "${FIX_BRANCH}"
          fi

      - name: Checkout fix branch
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPO }}
          ref: ${{ steps.branch.outputs.fix_branch }}
          token: ${{ secrets.CVE_CONTROLLER_PAT }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: './go.mod'

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@v1.1.4

      - name: Setup Python (for pip-audit)
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install pip-audit
        run: pip install pip-audit

      - name: Sync module graph
        run: go mod tidy

      - name: Scan for CVE (Go and Pip)
        id: scan
        run: |
          CVE_ID="${{ github.event.inputs.cve_id }}"
          # ---- Go (govulncheck): exit 0 = no vulns, 3 = vulns ----
          set +e; GOVOUT=$(govulncheck ./... 2>&1); EXIT=$?; set -e
          echo "$GOVOUT"
          if [ "$EXIT" -eq 0 ]; then
            echo "go_vulnerable=false" >> $GITHUB_OUTPUT; echo "go_package=" >> $GITHUB_OUTPUT; echo "go_module_unknown=false" >> $GITHUB_OUTPUT
          elif echo "$GOVOUT" | grep -qi "${CVE_ID}"; then
            PKG=$(echo "$GOVOUT" | grep -A 10 -i "${CVE_ID}" | grep "Module:" | head -1 | sed 's/.*Module: //'); [ -z "$PKG" ] && PKG=$(echo "$GOVOUT" | grep "Module:" | head -1 | sed 's/.*Module: //'); PKG=$(echo "$PKG" | xargs)
            echo "go_vulnerable=true" >> $GITHUB_OUTPUT
            echo "go_package=${PKG:-unknown}" >> $GITHUB_OUTPUT
            echo "go_module_unknown=$([ -z "$PKG" ] && echo true || echo false)" >> $GITHUB_OUTPUT
          elif [ "$EXIT" -eq 3 ]; then
            GOVJSON=$(govulncheck -json ./... 2>&1) || true
            if echo "$GOVJSON" | grep -qi "\"${CVE_ID}\""; then
              OSV_ID=$(echo "$GOVJSON" | while IFS= read -r L; do echo "$L" | jq -r --arg cve "$CVE_ID" 'if .osv? and (.osv.aliases[]? == $cve) then .osv.id else empty end' 2>/dev/null; done | head -1)
              PKG=$([ -n "$OSV_ID" ] && echo "$GOVJSON" | while IFS= read -r L; do echo "$L" | jq -r --arg osv "$OSV_ID" 'if .finding? and (.finding.osv == $osv) then .finding.trace[0].module else empty end' 2>/dev/null; done | head -1)
              PKG=$(echo "$PKG" | xargs)
              echo "go_vulnerable=true" >> $GITHUB_OUTPUT; echo "go_package=${PKG:-unknown}" >> $GITHUB_OUTPUT; echo "go_module_unknown=$([ -z "$PKG" ] && echo true || echo false)" >> $GITHUB_OUTPUT
            else
              echo "go_vulnerable=false" >> $GITHUB_OUTPUT; echo "go_package=" >> $GITHUB_OUTPUT; echo "go_module_unknown=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "::error title=govulncheck failed::exit $EXIT; $CVE_ID not determined."
            exit 1
          fi
          # ---- Pip (pip-audit): nested requirements, Pipfile, pyproject ----
          PY_FILES=$(find . \( -name '*requirements*.txt' -o -name 'pyproject.toml' -o -name 'Pipfile' \) 2>/dev/null | grep -v node_modules | sort)
          if [ -z "$PY_FILES" ]; then
            echo "pip_vulnerable=false" >> $GITHUB_OUTPUT; echo "pip_package=" >> $GITHUB_OUTPUT
          else
            PIP_ARGS=""
            for f in $PY_FILES; do
              [ -f "$f" ] || continue
              case "$f" in *Pipfile) PIP_ARGS="$PIP_ARGS --pipfile $f";; *) PIP_ARGS="$PIP_ARGS -r $f";; esac
            done
            echo "Pip files scanned: $PY_FILES"
            PYAUDIT=$(pip-audit $PIP_ARGS -f json 2>&1) || true
            echo "pip-audit output:"
            echo "$PYAUDIT" | jq . 2>/dev/null || echo "$PYAUDIT"
            PY_PKG=$(echo "$PYAUDIT" | jq -r --arg cve "$CVE_ID" '(.[]? | select(.vulns != null) | select(any(.vulns[]; (.aliases[]? == $cve))) | .name) // empty' 2>/dev/null | head -1)
            PY_PKG=$(echo "$PY_PKG" | xargs)
            if [ -n "$PY_PKG" ] && [ "$PY_PKG" != "null" ]; then
              echo "pip_vulnerable=true" >> $GITHUB_OUTPUT; echo "pip_package=${PY_PKG}" >> $GITHUB_OUTPUT
            else
              echo "pip_vulnerable=false" >> $GITHUB_OUTPUT; echo "pip_package=" >> $GITHUB_OUTPUT
            fi
          fi
          # vulnerable = go OR pip (recompute from what we wrote)
          grep -q "go_vulnerable=true" $GITHUB_OUTPUT 2>/dev/null && GO_V=1 || GO_V=0
          grep -q "pip_vulnerable=true" $GITHUB_OUTPUT 2>/dev/null && PIP_V=1 || PIP_V=0
          [ "$GO_V" = 1 ] || [ "$PIP_V" = 1 ] && echo "vulnerable=true" >> $GITHUB_OUTPUT || echo "vulnerable=false" >> $GITHUB_OUTPUT

      - name: No CVE detected
        if: steps.scan.outputs.vulnerable == 'false'
        run: echo "CVE ${{ github.event.inputs.cve_id }} not detected (Go + Pip scanned). Workflow complete."

  fix:
    name: Create Fix PR
    needs: scan
    if: needs.scan.outputs.vulnerable == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Go module unknown
        if: needs.scan.outputs.go_module_unknown == 'true'
        run: echo "::notice title=Go module unknown::Renovate may not open a Go PR. Fix ${{ github.event.inputs.cve_id }} manually."

      - name: Checkout (Renovate config)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CONFIG_REPO }}
          token: ${{ secrets.CVE_CONTROLLER_PAT }}

      - name: Run Renovate (Go)
        if: needs.scan.outputs.go_vulnerable == 'true'
        uses: renovatebot/github-action@v46.0.1
        with:
          configurationFile: .github/renovate-cve-config.js
          token: ${{ secrets.CVE_CONTROLLER_PAT }}
        env:
          RENOVATE_TARGET_REPO: ${{ env.TARGET_REPO }}
          RENOVATE_BASE_BRANCH: ${{ needs.scan.outputs.fix_branch }}
          RENOVATE_PACKAGE_NAME: ${{ needs.scan.outputs.go_package }}
          RENOVATE_CVE_ID: ${{ github.event.inputs.cve_id }}
          RENOVATE_MANAGER: gomod
          RENOVATE_COMPONENT: codeflare-operator
          LOG_LEVEL: info

      - name: Run Renovate (Pip)
        if: needs.scan.outputs.pip_vulnerable == 'true'
        uses: renovatebot/github-action@v46.0.1
        with:
          configurationFile: .github/renovate-cve-config.js
          token: ${{ secrets.CVE_CONTROLLER_PAT }}
        env:
          RENOVATE_TARGET_REPO: ${{ env.TARGET_REPO }}
          RENOVATE_BASE_BRANCH: ${{ needs.scan.outputs.fix_branch }}
          RENOVATE_PACKAGE_NAME: ${{ needs.scan.outputs.pip_package }}
          RENOVATE_CVE_ID: ${{ github.event.inputs.cve_id }}
          RENOVATE_MANAGER: pip_requirements
          RENOVATE_COMPONENT: codeflare-operator
          LOG_LEVEL: info

  recheck:
    name: Recheck PR
    needs: [fix, scan]
    if: needs.scan.outputs.vulnerable == 'true'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.find_prs.outputs.pr_number }}
      head_ref: ${{ steps.find_prs.outputs.head_ref }}
    steps:
      - name: Find Go and Pip PRs
        id: find_prs
        run: |
          FIX_BRANCH="${{ needs.scan.outputs.fix_branch }}"
          GO_LAST=$(echo "${{ needs.scan.outputs.go_package }}" | awk -F'/' '{print $NF}' | tr '.' '-')
          PIP_PKG="${{ needs.scan.outputs.pip_package }}"
          for i in $(seq 1 12); do
            PR_JSON=$(gh pr list --repo ${{ env.TARGET_REPO }} --base "${FIX_BRANCH}" --state open --json number,headRefName --limit 10)
            [ -z "$PR_JSON" ] || [ "$PR_JSON" = "[]" ] && sleep 10 && continue
            [ -n "$GO_LAST" ] && [ "$GO_LAST" != "unknown" ] && GO_PR=$(echo "$PR_JSON" | jq -r --arg s "$GO_LAST" '.[] | select(.headRefName | test($s)) | "\(.number)|\(.headRefName)"' | head -1)
            [ -n "$GO_PR" ] && echo "go_pr_number=${GO_PR%%|*}" >> $GITHUB_OUTPUT && echo "go_head_ref=${GO_PR#*|}" >> $GITHUB_OUTPUT
            [ -n "$PIP_PKG" ] && PIP_PR=$(echo "$PR_JSON" | jq -r --arg p "$PIP_PKG" '.[] | select(.headRefName | test($p)) | "\(.number)|\(.headRefName)"' | head -1)
            [ -n "$PIP_PR" ] && echo "pip_pr_number=${PIP_PR%%|*}" >> $GITHUB_OUTPUT && echo "pip_head_ref=${PIP_PR#*|}" >> $GITHUB_OUTPUT
            FIRST=$(echo "$PR_JSON" | jq -r '.[0] | "\(.number)|\(.headRefName)"')
            [ -n "$FIRST" ] && echo "pr_number=${FIRST%%|*}" >> $GITHUB_OUTPUT && echo "head_ref=${FIRST#*|}" >> $GITHUB_OUTPUT
            exit 0
          done
          echo "go_pr_number=" >> $GITHUB_OUTPUT; echo "go_head_ref=" >> $GITHUB_OUTPUT; echo "pip_pr_number=" >> $GITHUB_OUTPUT; echo "pip_head_ref=" >> $GITHUB_OUTPUT; echo "pr_number=" >> $GITHUB_OUTPUT; echo "head_ref=" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.CVE_CONTROLLER_PAT }}

      - name: No PR from Renovate
        if: steps.find_prs.outputs.pr_number == ''
        run: echo "::warning title=No Renovate PR::Fix ${{ github.event.inputs.cve_id }} manually."

      - name: Checkout Go PR branch
        if: needs.scan.outputs.go_vulnerable == 'true' && steps.find_prs.outputs.go_head_ref != ''
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPO }}
          ref: ${{ steps.find_prs.outputs.go_head_ref }}
          token: ${{ secrets.CVE_CONTROLLER_PAT }}

      - name: Setup Go (recheck)
        if: needs.scan.outputs.go_vulnerable == 'true' && steps.find_prs.outputs.go_head_ref != ''
        uses: actions/setup-go@v5
        with:
          go-version-file: './go.mod'

      - name: Recheck Go CVE
        if: needs.scan.outputs.go_vulnerable == 'true' && steps.find_prs.outputs.go_head_ref != ''
        id: recheck_go
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@v1.1.4
          CVE_ID="${{ github.event.inputs.cve_id }}"
          [ "${{ github.event.inputs.force_recheck_fail }}" = "true" ] && echo "go_still_vulnerable=true" >> $GITHUB_OUTPUT && exit 0
          go mod tidy
          set +e
          GOVOUT=$(govulncheck ./... 2>&1)
          EXIT=$?
          set -e
          echo "$GOVOUT"
          if echo "$GOVOUT" | grep -qi "${CVE_ID}"; then
            echo "go_still_vulnerable=true" >> $GITHUB_OUTPUT
          elif [ "$EXIT" -eq 0 ]; then
            echo "go_still_vulnerable=false" >> $GITHUB_OUTPUT
          elif [ "$EXIT" -eq 3 ]; then
            GOVJSON=$(govulncheck -json ./... 2>&1) || true
            if echo "$GOVJSON" | grep -qi "\"${CVE_ID}\""; then
              echo "go_still_vulnerable=true" >> $GITHUB_OUTPUT
            else
              echo "go_still_vulnerable=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "go_still_vulnerable=true" >> $GITHUB_OUTPUT
          fi

      - name: Close Go PR (still vulnerable)
        if: needs.scan.outputs.go_vulnerable == 'true' && steps.find_prs.outputs.go_pr_number != '' && steps.recheck_go.outputs.go_still_vulnerable == 'true'
        run: |
          gh pr close ${{ steps.find_prs.outputs.go_pr_number }} --repo ${{ env.TARGET_REPO }} \
            --comment "Recheck failed: did not fix **${{ github.event.inputs.cve_id }}** (Go). Fix manually."
        env:
          GH_TOKEN: ${{ secrets.CVE_CONTROLLER_PAT }}

      - name: Checkout Pip PR branch
        if: needs.scan.outputs.pip_vulnerable == 'true' && steps.find_prs.outputs.pip_head_ref != ''
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPO }}
          ref: ${{ steps.find_prs.outputs.pip_head_ref }}
          token: ${{ secrets.CVE_CONTROLLER_PAT }}

      - name: Setup Python (recheck)
        if: needs.scan.outputs.pip_vulnerable == 'true' && steps.find_prs.outputs.pip_head_ref != ''
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Recheck Pip CVE
        if: needs.scan.outputs.pip_vulnerable == 'true' && steps.find_prs.outputs.pip_head_ref != ''
        id: recheck_pip
        run: |
          pip install pip-audit -q
          CVE_ID="${{ github.event.inputs.cve_id }}"
          [ "${{ github.event.inputs.force_recheck_fail }}" = "true" ] && echo "pip_still_vulnerable=true" >> $GITHUB_OUTPUT && exit 0
          PY_FILES=$(find . \( -name '*requirements*.txt' -o -name 'pyproject.toml' -o -name 'Pipfile' \) 2>/dev/null | grep -v node_modules | sort)
          if [ -z "$PY_FILES" ]; then
            echo "pip_still_vulnerable=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          PIP_ARGS=""
          for f in $PY_FILES; do
            [ -f "$f" ] || continue
            case "$f" in *Pipfile) PIP_ARGS="$PIP_ARGS --pipfile $f";; *) PIP_ARGS="$PIP_ARGS -r $f";; esac
          done
          echo "Pip files scanned: $PY_FILES"
          set +e
          PYAUDIT=$(pip-audit $PIP_ARGS -f json 2>&1)
          set -e
          echo "pip-audit output:"
          echo "$PYAUDIT" | jq . 2>/dev/null || echo "$PYAUDIT"
          if echo "$PYAUDIT" | grep -qi "\"${CVE_ID}\""; then
            echo "pip_still_vulnerable=true" >> $GITHUB_OUTPUT
          else
            echo "pip_still_vulnerable=false" >> $GITHUB_OUTPUT
          fi

      - name: Close Pip PR (still vulnerable)
        if: needs.scan.outputs.pip_vulnerable == 'true' && steps.find_prs.outputs.pip_pr_number != '' && steps.recheck_pip.outputs.pip_still_vulnerable == 'true'
        run: |
          gh pr close ${{ steps.find_prs.outputs.pip_pr_number }} --repo ${{ env.TARGET_REPO }} \
            --comment "Recheck failed: did not fix **${{ github.event.inputs.cve_id }}** (Pip). Fix manually."
        env:
          GH_TOKEN: ${{ secrets.CVE_CONTROLLER_PAT }}

  lint:
    name: Lint Renovate PR
    needs: [recheck, scan]
    if: needs.scan.outputs.vulnerable == 'true' && needs.recheck.outputs.pr_number != ''
    runs-on: ubuntu-latest
    container:
      image: quay.io/opendatahub/pre-commit-go-toolchain:v0.2
      env:
        XDG_CACHE_HOME: /cache
        GOCACHE: /cache/go-build
        GOMODCACHE: /cache/go-mod
        PRE_COMMIT_HOME: /cache/pre-commit
      volumes:
        - /cache
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPO }}
          ref: ${{ needs.recheck.outputs.head_ref }}
          token: ${{ secrets.CVE_CONTROLLER_PAT }}

      - name: Set Go
        uses: actions/setup-go@v5
        with:
          go-version-file: './go.mod'

      - name: Cache
        uses: actions/cache@v4
        with:
          path: /cache
          key: ${{ runner.os }}-cache-${{ hashFiles('**/go.sum', '.pre-commit-config.yaml') }}

      - name: Run pre-commit checks
        run: pre-commit run --show-diff-on-failure --color=always --all-files
